import re
from pathlib import Path
from schemas.ui_test_plan_model import UITestPlanModel


def _safe_name(name: str) -> str:
    normalized = re.sub(r"[^a-zA-Z0-9_]+", "_", name.strip().lower())
    normalized = re.sub(r"_+", "_", normalized).strip("_")
    if not normalized:
        normalized = "generated_test"
    if normalized[0].isdigit():
        normalized = f"test_{normalized}"
    if not normalized.startswith("test_"):
        normalized = f"test_{normalized}"
    return normalized


def generate_pytest_from_ui_plan(plan: UITestPlanModel, output_file: Path) -> None:
    lines = []
    lines.append("# Auto-generated by scripts/generate_ui_tests_from_prompt.py")
    lines.append("")

    for test_case in plan.test_cases:
        fn_name = _safe_name(test_case.test_name)
        lines.append(f"def {fn_name}(page, base_url):")
        lines.append(f"    \"\"\"{test_case.description}\"\"\"")
        lines.append(f"    page.goto(base_url.rstrip('/') + '{test_case.path}')")

        for step in test_case.steps:
            if step.action == "goto":
                path = step.value or "/"
                normalized = path if path.startswith("/") else f"/{path}"
                lines.append(f"    page.goto(base_url.rstrip('/') + '{normalized}')")

            elif step.action == "click":
                lines.append(
                    f"    page.locator({step.selector!r}).click(timeout={step.timeout_ms})"
                )

            elif step.action == "fill":
                lines.append(
                    f"    page.locator({step.selector!r}).fill({(step.value or '')!r}, timeout={step.timeout_ms})"
                )

            elif step.action == "press":
                lines.append(
                    f"    page.locator({step.selector!r}).press({(step.value or 'Enter')!r}, timeout={step.timeout_ms})"
                )

            elif step.action == "expect_text":
                expected = step.expected or ""
                lines.append(
                    f"    assert {expected!r} in page.locator({step.selector!r}).inner_text(timeout={step.timeout_ms})"
                )

            elif step.action == "expect_title_contains":
                expected = step.expected or ""
                lines.append(f"    assert {expected!r} in page.title()")

            elif step.action == "expect_url_contains":
                expected = step.expected or ""
                lines.append(f"    assert {expected!r} in page.url")

            elif step.action == "wait_for_selector":
                lines.append(
                    f"    page.wait_for_selector({step.selector!r}, timeout={step.timeout_ms})"
                )

        lines.append("")

    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text("\n".join(lines))
